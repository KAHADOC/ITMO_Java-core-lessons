package lesson05;


import java.util.Arrays;

public class ArraysLesson {
    public static void main(String[] args) {
        // Массивы - непрерывная область памяти для хранения значений одного типа
        // Элементы (значения) в массиве хранятся под индексами (нумерация начинается 0)
        // 1. объявление переменной массива: ТипДанных[] имяПеременной
        // 2. инициализация пустого массива: new ТипДанных[len]
        // Будет создан массив на len элементов, заполненный значениями по умолчанию.
        // Для чисел - 0, для логического типа - false,
        // для char - '\u0000' или 0 (пустой символ),
        // для ссылочных типов - null
        // 3. инициализация заполненного массива: {значение1, значение2, значение3,..., значениеN}
        // 4. переопределение массива = new int[]{значение1, значение2, значение3,..., значениеN}
        // 5. длина массива - количество элементов массива, неотрицательное значение типа int
        // длину изменить нельзя
        // длина массива может задаваться через переменную или выражение
        // 6. обращение к элементу массива имяПеременной[индекс]
        // обращение к несуществующему индексу (выход за пределы массива) - java.lang.ArrayIndexOutOfBoundsException

        // создан массив на 3 элемента, заполненный значениями по умолчанию, т.е. 0.0
        int len = 3;
        double[] prices = new double[len]; // [0.0, 0.0, 0.0]
        // значение элемента с индексом 0 будет заменено на 67.5
        prices[0] = 67.5; // [67.5, 0.0, 0.0]
        // значение элемента с индексом 1 будет заменено на 100.5
        prices[1] = 100.5; // [67.5, 100.5, 0.0]
        // значение элемента с индексом 2 будет заменено на 300.0
        prices[2] = 300; // [67.5, 100.5, 300.0]

        int[] temperatures = {12, 14, 15, 17, 22, 24, 10}; // 7
        // значение элемента с индексом 0 будет выведено в консоль
        System.out.println(temperatures[0]); // 12
        // значение элемента с индексом 3 будет заменено на 20
        temperatures[3] = 20;

        // размер массива
        System.out.println(prices.length); // 3
        System.out.println(temperatures.length); // 7

        // перебор массива #1:
        // есть возможность заменять значения в цикле
        // есть возможность перебирать массив
        // не только от первого элемента к последнему

        // переменная i хранит индекс элемента массива
        // и обновляется с каждой итерацией цикла
        // для доступа к элементам массива используются []
        for (int i = 0; i < prices.length; i++) { // fori
            // увеличиваем значение каждого элемента массива,
            // начиная с первого
            prices[i] *= 1.2;
        }
        // {12, 14, 15, 17, 22, 24, 10}
        for (int i = temperatures.length - 1; i >= 0; i--) { // fori
            if (temperatures[i] >= 20) {
                temperatures[i] = -temperatures[i];
            }
        }

        // перебор массива #2:
        // нет доступа к индексам
        // нет возможности заменять значения в цикле
        // можно перебирать массив только от первого элемента к последнему

        // на каждой итерации цикла в переменную temperature копируется значения элемента массива
        int sum = 0;
        for (var /*int*/ temperature : temperatures) { // iter
            sum += temperature;
        }
        System.out.println("Средняя температура: " + ((double) sum / temperatures.length));

        for (var/*double*/ price : prices) {
            if (price > 100) {
                System.out.println(price);
                break;
            }
        }

        // Класс Arrays содержит методы для работы с массивами
        // Необходим импорт: import java.util.Arrays
        int[] ids = {2, 5, 7, 8, 9, 12, 44, 67};

        System.out.println(Arrays.toString(ids));

        // методы для работы с массивами
        double[] temps = {45.7, 22.9, 12.0, 33.8, 98.1};
        // СОРТИРОВКА
        Arrays.sort(temps); // меняет исходный массив
        System.out.println(Arrays.toString(temps));

        // БИНАРНЫЙ ПОИСК [12.0, 22.9, 33.8, 45.7, 98.1]
        System.out.println(Arrays.binarySearch(temps, 98.1)); // 4
        System.out.println(Arrays.binarySearch(temps, 6)); // -1

        // СОЗДАНИЕ КОПИЙ
        // 1) Позволяет сделать полную копию массива
        double[] newTemps01 = temps.clone();
        System.out.println(Arrays.toString(newTemps01));

        // 2) Позволяет скопировать несколько первых элементов массива
        // или сделать полную копию массива
        double[] newTemps02 = Arrays.copyOf(temps, 3);
        System.out.println(Arrays.toString(newTemps02));

        // 3) System.arraycopy(Object src, int srcPos, Object dst, int dstPos, int len)
        // Метод копирует len элементов массива src, начиная с позиции srcPos,
        // в массив dst, начиная с позиции dstPos.
        // Массив dst должен иметь достаточный размер,
        // чтобы в нем поместились все копируемые элементы.
        // [12.0, 22.9, 33.8, 45.7, 98.1]
        double[] newTemps03 = new double[30];
        System.arraycopy(temps, 0, newTemps03, 10, temps.length);
        System.out.println(Arrays.toString(newTemps03));

        // Работа с массивами:
        // 1. Сортировка
        // 2. Бинарный поиск
        // 3. Перебор от первого элемента
        // 4. Перебор от последнего элемента
        // 5. Перебор через два указателя (для сокращения числа вложенных циклов)
        // 6. Метод скользящего окна. Используется при решении проблем с подмассивами,
        // подстроками ('найти сумму элементов подмассива', 'найти среднее подмассива' и т.п)
        // Логика: два указателя двигаются в одну сторону не пересекаясь, создавая окно.
        // В окно поочередно добавляется один элемент, из окна удаляется один элемент.
        // Промежуточный результат высчитывается, при необходимости сохраняется.
        // Длинна окна может быть заданной или динамической (тогда окно сначала расширяется,
        // а потом сужается)
        // wSize = 3;
        // [3, 4, 5, 7, 1, 2, 9]
        // wStart = 0, wEnd = 0;
        /*
        int sum = 0;
        for (int wEnd = 0; wEnd < arr.len; wEnd++) {
            sum+=arr[wEnd];
            if (){
                sum-=arr[wStart];
                wStart++;
            }
        }

        int[] someArr = {3, 4, 5, 7, 1, 2, 9};
        int target = 20;
        int wStart = 0;
        int subArrSum = 0;
        int subArrLen = 10000;
        for (int wEnd = 0; wEnd < someArr.length; wEnd++) { // расширение окна
            subArrSum += someArr[wEnd];
            while (subArrSum >= target){
                subArrLen = Math.min(subArrLen, wEnd - wStart + 1)
                subArrSum -= someArr[wStart];
                wStart++;
            }
        }
        */

        // TODO #1
        // Дан отсортированный массив целых чисел. Найти максимальный элемент
        int[] task01 = {4, 6, 89, 90, 220, 560, 780};
        System.out.println(task01[task01.length-1]);

        // TODO #2
        // Дан отсортированный массив положительных целых чисел task02.
        // Найти в данном массиве такие два числа (одну пару), чтобы их сумма была равна targetSum.
        int[] task02 = {1, 3, 7, 8, 9, 10, 13};
        int targetSum = 10;
        // вложенный цикл
        out: for (int i = 0; i < task02.length; i++) {
            for (int j = i + 1; j < task02.length; j++) {
                if (task02[i] + task02[j] == targetSum) {
                    System.out.println(task02[i]);
                    System.out.println(task02[j]);
                    break out;
                }
            }
        }
        // два указателя
        int low = 0;
        int high = task02.length - 1;
        while (low < high){
            int sumToFind = task02[low] + task02[high];
            if (sumToFind == targetSum) {
                System.out.println(task02[low]);
                System.out.println(task02[high]);
                break;
            }
            if (sumToFind > targetSum) high--;
            else low++;
        }
    }
}
