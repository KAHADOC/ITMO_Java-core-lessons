package lesson05;


import java.util.Arrays;

public class ArraysLesson {
    public static void main(String[] args) {
        // Массивы - непрерывная область памяти для хранения значений одного типа
        // Элементы (значения) в массиве хранятся под индексами (нумерация начинается 0)
        // 1. объявление переменной массива: ТипДанных[] имяПеременной
        // 2. инициализация пустого массива: new ТипДанных[len]
        // Будет создан массив на len элементов, заполненный значениями по умолчанию.
        // Для чисел - 0, для логического типа - false,
        // для char - '\u0000' или 0 (пустой символ),
        // для ссылочных типов - null
        // 3. инициализация заполненного массива: {значение1, значение2, значение3,..., значениеN}
        // 4. переопределение массива = new int[]{значение1, значение2, значение3,..., значениеN}
        // 5. длина массива - количество элементов массива, неотрицательное значение типа int
        // длину изменить нельзя
        // длина массива может задаваться через переменную или выражение
        // 6. обращение к элементу массива имяПеременной[индекс]
        // обращение к несуществующему индексу (выход за пределы массива) - java.lang.ArrayIndexOutOfBoundsException

        // создан массив на 3 элемента, заполненный значениями по умолчанию, т.е. 0.0
        int len = 3;
        double[] prices = new double[len]; // [0.0, 0.0, 0.0]
        // значение элемента с индексом 0 будет заменено на 67.5
        prices[0] = 67.5; // [67.5, 0.0, 0.0]
        // значение элемента с индексом 1 будет заменено на 100.5
        prices[1] = 100.5; // [67.5, 100.5, 0.0]
        // значение элемента с индексом 2 будет заменено на 300.0
        prices[2] = 300; // [67.5, 100.5, 300.0]

        int[] temperatures = {12, 14, 15, 17, 22, 24, 10}; // 7
        // значение элемента с индексом 0 будет выведено в консоль
        System.out.println(temperatures[0]); // 12
        // значение элемента с индексом 3 будет заменено на 20
        temperatures[3] = 20;

        // размер массива
        System.out.println(prices.length); // 3
        System.out.println(temperatures.length); // 7

        // перебор массива #1:
        // есть возможность заменять значения в цикле
        // есть возможность перебирать массив
        // не только от первого элемента к последнему

        // переменная i хранит индекс элемента массива
        // и обновляется с каждой итерацией цикла
        // для доступа к элементам массива используются []
        for (int i = 0; i < prices.length; i++) { // fori
            // увеличиваем значение каждого элемента массива,
            // начиная с первого
            prices[i] *= 1.2;
        }
        // {12, 14, 15, 17, 22, 24, 10}
        for (int i = temperatures.length - 1; i >= 0; i--) { // fori
            if (temperatures[i] >= 20) {
                temperatures[i] = -temperatures[i];
            }
        }

        // перебор массива #2:
        // нет доступа к индексам
        // нет возможности заменять значения в цикле
        // можно перебирать массив только от первого элемента к последнему

        // на каждой итерации цикла в переменную temperature копируется значения элемента массива
        int sum = 0;
        for (var /*int*/ temperature : temperatures) { // iter
            sum += temperature;
        }
        System.out.println("Средняя температура: " + ((double) sum / temperatures.length));

        for (var/*double*/ price : prices) {
            if (price > 100) {
                System.out.println(price);
                break;
            }
        }

        // Многомерные массивы
        int[][] field = {
                {1, 0, 0},
                {1, 3, 2, 0},
        };
        System.out.println(field[1][3]); // 0
        System.out.println(field[0][0]); // 1

        int[][] matrix = new int[3][3]; // [[0,0,0],[0,0,0],[0,0,0]]
        matrix[0][0] = 10;
        matrix[1][0] = 100;

        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = (int) (Math.random() * 1000);
            }
        }

        char[][] animals = new char[3][]; // [null, null, null]
        // [
        //  ['\u0000', '\u0000'],
        //  null,
        //  null
        // ]
        animals[0] = new char[2];
        // [
        //  ['\u0000', '\u0000'],
        //  ['\u0000', '\u0000', '\u0000'],
        //  null
        // ]
        animals[1] = new char[3];
        // [
        //  ['\u0000', '\u0000'],
        //  ['\u0000', '\u0000', '\u0000'],
        //  ['\u0000', '\u0000', '\u0000', '\u0000']
        // ]
        animals[2] = new char[4];

        // Класс Arrays содержит методы для работы с массивами
        // Необходим импорт: import java.util.Arrays
        int[] ids = {2, 5, 7, 8, 9, 12, 44, 67};

        System.out.println(Arrays.toString(ids));

        // методы для работы с массивами
        double[] temps = {45.7, 22.9, 12.0, 33.8, 98.1};
        // СОРТИРОВКА
        Arrays.sort(temps); // меняет исходный массив
        System.out.println(Arrays.toString(temps));

        // БИНАРНЫЙ ПОИСК [12.0, 22.9, 33.8, 45.7, 98.1]
        System.out.println(Arrays.binarySearch(temps, 98.1)); // 4
        System.out.println(Arrays.binarySearch(temps, 6)); // -1

        // СОЗДАНИЕ КОПИЙ
        // 1) Позволяет сделать полную копию массива
        double[] newTemps01 = temps.clone();
        System.out.println(Arrays.toString(newTemps01));

        // 2) Позволяет скопировать несколько первых элементов массива
        // или сделать полную копию массива
        double[] newTemps02 = Arrays.copyOf(temps, 3);
        System.out.println(Arrays.toString(newTemps02));

        // 3) System.arraycopy(Object src, int srcPos, Object dst, int dstPos, int len)
        // Метод копирует len элементов массива src, начиная с позиции srcPos,
        // в массив dst, начиная с позиции dstPos.
        // Массив dst должен иметь достаточный размер,
        // чтобы в нем поместились все копируемые элементы.
        // [12.0, 22.9, 33.8, 45.7, 98.1]
        double[] newTemps03 = new double[30];
        System.arraycopy(temps, 0, newTemps03, 10, temps.length);
        System.out.println(Arrays.toString(newTemps03));

        // Работа с массивами:
        // 1. Сортировка
        // 2. Бинарный поиск
        // 3. Перебор от первого элемента
        // 4. Перебор от последнего элемента
        // 5. Перебор через два указателя (для сокращения числа вложенных циклов)
        // 6. Метод скользящего окна. Используется при решении проблем с подмассивами, подстроками
        // ('найти сумму элементов подмассива', 'найти среднее подмассива' и т.п)
        // Логика: два указателя двигаются в одну сторону не пересекаясь, создавая окно.
        // В окно поочередно добавляется один элемент, из окна удаляется один элемент.
        // Промежуточный результат высчитывается, при необходимости сохраняется.
        // Длинна окна может быть заданной или динамической (тогда окно сначала расширяется,
        // а потом сужается)


        // TODO #1
        // Дан отсортированный массив целых чисел. Найти максимальный элемент
        int[] task01 = {4, 6, 89, 90, 22, 56, 78};

        // TODO #2
        // Дан отсортированный массив положительных целых чисел task02.
        // Найти в данном массиве такие два числа (одну пару), чтобы их сумма была равна targetSum.
        int[] task02 = {1, 3, 7, 8, 9, 10, 13};
        int targetSum = 10;

        // TODO #3
        // Найти минимальную длину подмассива для task03,
        // сумма элементов которого больше или равна task03Sum
        int[] task03 = {300, 630, 136, 440, 1200, 55, 947, 390, 780, 250};
        int task03Sum = 2000;

    }
}
